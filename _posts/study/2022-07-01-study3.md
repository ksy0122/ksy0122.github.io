---
layout: single
title: "C언어 프로그래밍 3번째 시간 - 데이터 표현방식의 이해"
categories:
  - C_study
---

## C언어 공부시작 3일차

### 데이터 표현

* 2진수 : 2개의 기호를 이용해서 데이터를 표현하는 방식          ex) 0, 1, 10, 11, 100, 101, ...
* 10진수 : 10개의 기호를 이용해서 데이터를 표현하는 방식        ex) 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...
* 16진수 : 16개의 기호를 이용해서 데이터를 표현하는 방식        ex) 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, ...
<br> <br>

'비트'는 컴퓨터가 표현하는 데이터의 최소단위로서 2진수 값 하나를 저장할 수 있는 메모리의 크기를 뜻하는 단위이다. 또한 비트를 8개 묶으면 '바이트(byte)'라는 단위가 구성된다.
<br> <br>

#### 8진수와 16진수를 이용한 데이터 표현

```
int num1 = 10;      // 특별한 선언이 없으면 10진수의 표현
int num2 = 0xA;     // 0x로 시작하면 16진수로 인식
int num3 = 012;     // 0으로 시작하면 8진수로 인식
  ```

위 주석에서 언급하고 있듯이 다음과 같이 시작하면 8진수와 16진수를 표현할 수 있다. 이때 한가지 주의할 것은, 표현의 방식이 다르다고 해서 저장되는 값이 달라지는 것은 아니라는 점이다. 16진수 A와 8진수 12는 모두 10진수로 10이다. 즉, 위의 세 문장에 의해서 변수에 초기화되는 값은 모두 동일하다. 다만, 초기화에 사용된 표현의 방식에만 차이가 있을 뿐이다. 물론 컴퓨터는 내부적으로 2진수의 형태로 값을 저장한다.
<br> <br>

### 정수와 실수의 표현방식

#### 정수의 표현방식

* 정수의 가장 왼쪽에 존재하는 비트는 '부호비트'이다. <br> <br>
컴퓨터가 1바이트 메모리 공간에 정수 +1을 저장하려 한다. <br>
 
 ``
 00000001
  ``
  <br>
  
 다음과 같이 정수를 표현하는데 있어서 가장 왼쪽에 존재하는 비트는 부호를 표현하는데 사용된다. 양수라면 0, 음수라면 1을 저장하여 부호를 표시한다. 그래서 이 비트를 가리켜 **MSB(Most Significant Bit)** 라 하고, 가장 중요한 비트라는 뜻을 지닌다. 가장 왼쪽 비트를 제외한 나머지 비트들은 데이터의 크기를 나타낸다. <br> <br>

* 음의 정수를 표현할 때에는 2의 보수를 취해야 한다.

정수 -5를 표현할 때, +5를 2진수로 표현하고 그것을 1의 보수를 취한 후, 1을 더하는 방식을 사용해야한다. <br> <br>

```
00000101 [정수 +5]  --- 1의 보수 --->  11111010  --- 1을 더한다. --->  11111011 [정수 -5]
  ```
위와 같이 음수를 표현하기 위해 거쳤던 과정을 가리켜 **'2의 보수법'** 이라 한다. <br> <br>

#### 실수의 표현방식

* 실수를 표현하는 기본 방식
2바이트 메모리로 실수를 표현해보자. 
<br> <br>
``
1000000100000101
  ``
  
위의 수를 실수로 표현해 보면,
```
「1」 「0000001」 「00000101」
(부호) (---e---)   (---m---)

±(1.m) × 2^(e-127)   실수의 표현을 위해 정의된 수식
  ```
다음과 같이 표현할 수 있다. 위 식을 이용하면 적은 비트 수를 가지고도 보다 넓은 범위의 실수를 표현할 수 있다. <br> <br>

* 컴퓨터가 실수를 표현하는 방식에는 오차가 존재한다.

위에서 컴퓨터가 실수를 어떻게 표현하는지 알아보았다. 적은 비트위 수를 가지고도 넓은 범위의 실수를 표현할 수 잇다는 것도 이해했다. 그러나 이렇게 장점만 있는 것은 아니다. 위 식에 의한 실수의 표현 방식에는 '넓은 범위의 실수를 표현할 수 있지만, 실수의 표현에 오차가 존재한다.'는 특성이 존재한다. <br>
오차가 존재하는 이유는 위 실수를 표현한 식으로는 모든 실수를 정확히 표현할 수 없기 때문이다. <br>
컴퓨터는 우리가 표현하고자 하는 실수의 값을 정확하게 표현하는 것이 아니라, 아주 가까운, 문제가 없을 만큼의 근사치를 통해서 실수를 표현하게 된다. 따라서 실수를 표현하는데 있어서 오차가 존재하는 것은 당연한 일이며, 이러한 오차를 가리켜 **'부동 소수점 오차'** 라고 한다. <br> <br>

### 비트 연산자

|연산자|연산자의 기능|결합방향|
|:------:|:------:|:-------:|
| & | 비트단위로 AND 연산을 한다. | -> |
| (shift)\ | 비트단위로 OR 연산을 한다. | -> |
| ^ | 비트단위로 XOR 연산을 한다. | -> |
| ~ | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. <br> ex) num ~ 2;  // num은 변화 없음, 반전 결과만 반환 | <- |
| << | 피연산자의 비트 열을 왼쪽으로 이동시킨다. <br> ex) num << 2;  // num은 변화 없음, 두 칸 왼쪽 이동 결과만 반환 | -> |
| >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다. <br> ex) num >> 2;  // num은 변화 없음, 두 칸 오른쪽 이동 결과만 반환 | -> |

<br>

#### << 연산자 : 비트의 왼쪽 이동(Shift)

<< 연산자는 두 개의 피연산자를 요구하며 다음의 의미를 갖는다.
* num1 << num2   num1의 비트 열을 num2칸씩 왼쪽으로 이동시킨 결과를 반환
* 8 << 2         정수 8의 비트 열을 2칸씩 왼쪽으로 이동시킨 결과를 반환

이 연산자의 특징은 비트의 열을 왼쪽으로 1칸씩 이동시킬 때마다 정수의 값은 두 배가 된다는 것이다. 이 사실을 기억하면, 상황에 따라서 곱셈과 나눗셈 연산은 비트의 이동 연산으로 대체할 수 있으며, 이는 성능의 향상으로 이어진다. CPU 입장에서는 곱셈과 나눗셈이 비트의 이동보다 부담스러운 연산이기 때문이다. <br> <br>

#### >> 연산자 : 비트의 오른쪽 이동(Shift)

비트 연산자의 >> 연산자와 << 연산자의 가장 큰 차이점은 비트의 열을 이동시키는 방향에 있다. <br>

``
num1 >> num2
  ``

다음과 같이 연산하였을 때, num2의 크기만큼 num1의 비트 열이 오른쪽으로 이동한 결과가 반환된다. 물론 num1이 양수라면(MSB가 0이라면), 이동으로 인해서 밀려나는 오른쪽의 비트들은 소멸되고 이동으로 인해서 생긴 왼쪽의 빈 자리는 0으로 채워진다. 그러나 num1이 음수라면 이야기는 달라진다. <br> <br>

``
11111111 1111111 11111111 11110000
  ``

다음은 -16에 해당하는 비트 열이다. 이것을 >> 연산을 통해서 2칸씩 오른쪽으로 이동시키면 그 결과는 CPU에 따라서 달라진다. 음의 값을 유지하기 위해 1을 채우는 CPU도 있고, 음의 값 유지에 상관하지 않고 0을 채우는 CPU도 있기 때문이다.

## 예제
Q. 다음 연산의 결과를 출력하는 프로그램을 작성해보자. 단, * 연산자와 / 연산자를 사용하지 않고 구현해야 한다. <br>
``
3 × 8 ÷ 4
  ``
<br>

물론 중간과정을 생략하거나 적절히 암산하지 않고, 반드시 곱셈에 대응하는 연산과 나눗셈에 대응하는 연산을 거쳐서 해결해야 한다. <br> <br>

A.
```

  ```



